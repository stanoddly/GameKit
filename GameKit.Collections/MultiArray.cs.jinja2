// Generated using jinja2-cli: jinja2 MultiArray.cs.jinja2 > MultiArray.cs
using System;

namespace GameKit.Collections;

{% for type in [("class", ""), ("struct", "Struct")] -%}
{% for n in range(1, 11) -%}
public {{type[0]}} MultiArray{{type[1]}}<{% for i in range(1, n + 1) %}TValue{{i}}{% if not loop.last %}, {% endif %}{% endfor %}>
{
    private const int DefaultCapacity = 32;
    private int _count;
    {% for i in range(1, n + 1) %}
    private TValue{{i}}[] _values{{i}};
    {%- endfor %}

    public MultiArray{{type[1]}}(int initialCapacity)
    {
        if (initialCapacity < 0)
            throw new ArgumentOutOfRangeException(nameof(initialCapacity));
        {% for i in range(1, n + 1) %}
        _values{{i}} = new TValue{{i}}[initialCapacity];
        {%- endfor %}
    }

    public MultiArray{{type[1]}}()
    {
        {% for i in range(1, n + 1) -%}
        _values{{i}} = new TValue{{i}}[DefaultCapacity];
        {% endfor %}
    }

    public int Count => _count;

    private void EnsureCapacity(int minCapacity)
    {
        int capacity = _values1.Length;
        if (minCapacity > capacity)
        {
            int newCapacity = Math.Max(capacity * 2, minCapacity);

            {% for i in range(1, n + 1) %}
            Array.Resize(ref _values{{i}}, newCapacity);
            {%- endfor %}
        }
    }

    public void Add({% for i in range(1, n + 1) %}TValue{{i}} value{{i}}{% if not loop.last %}, {% endif %}{% endfor %})
    {
        EnsureCapacity(_count + 1);

        {% for i in range(1, n + 1) %}
        _values{{i}}[_count] = value{{i}};
        {%- endfor %}

        _count++;
    }

    {% for i in range(1, n + 1) %}
    public TValue{{i}} GetValue{{i}}(int index)
    {
        if (index < 0 || index >= _count)
            throw new ArgumentOutOfRangeException(nameof(index));

        return _values{{i}}[index];
    }

    public void SetValue{{i}}(int index, TValue{{i}} value)
    {
        if (index < 0 || index >= _count)
            throw new ArgumentOutOfRangeException(nameof(index));

        _values{{i}}[index] = value;
    }

    public Span<TValue{{i}}> Values{{i}} => new Span<TValue{{i}}>(_values{{i}}, 0, _count);
    {% endfor %}

    public bool SwapRemove(int index)
    {
        if (index < 0 || index >= _count)
            return false;

        int lastIndex = _count - 1;
        if (index != lastIndex)
        {
            {% for i in range(1, n + 1) %}
            _values{{i}}[index] = _values{{i}}[lastIndex];
            {%- endfor %}
        }
        _count--;
        return true;
    }

    public void Clear()
    {
        {% for i in range(1, n + 1) %}
        Array.Clear(_values{{i}}, 0, _count);
        {%- endfor %}
        _count = 0;
    }

    public void TrimExcess()
    {
        int capacity = _values1.Length;
        if (_count < capacity * 0.9)
        {
            int newCapacity = Math.Max(DefaultCapacity, _count);
            {% for i in range(1, n + 1) %}
            Array.Resize(ref _values{{i}}, newCapacity);
            {%- endfor %}
        }
    }
}

{% endfor %}
{% endfor %}
