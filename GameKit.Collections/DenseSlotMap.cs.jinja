namespace GameKit.Collections;
{% for type in [("class", ""), ("struct", "Struct")] -%}
{% for n in range(1, 9) -%}

public {{type[0]}} DenseSlotMap{{type[1]}}<{% for i in range(1, n + 1) %}{% if not loop.first %}, {% endif %}TValue{{i}}{% endfor %}>
{
    private const uint Tombstone = uint.MaxValue;
    private FastListStruct<Handle> _handles;
    private MultiArrayStruct<Handle{% for i in range(1, n + 1) %}, TValue{{i}}{% endfor %}> _dense;
    private uint _freeIndex;
    private uint _lastFreeIndex;

    public DenseSlotMap{{type[1]}}()
    {
        _handles = new FastListStruct<Handle>();
        _dense = new MultiArrayStruct<Handle{% for i in range(1, n + 1) %}, TValue{{i}}{% endfor %}>();
        _freeIndex = Tombstone;
        _lastFreeIndex = Tombstone;
    }

    public Handle Add({% for i in range(1, n + 1) %}{% if not loop.first %}, {% endif %}TValue{{i}} value{{i}}{% endfor %})
    {
        // If there is nothing to recycle create new
        if (_freeIndex == Tombstone)
        {
            uint index = (uint)_dense.Count;
            Handle handle = new Handle { Index = index, Version = 0 };
            uint handleIndex = (uint)_handles.Add(handle);

            _dense.Add(new Handle(handleIndex, 0){% for i in range(1, n + 1) %}, value{{i}}{% endfor %});

            return handle;
        }
        // Recycle
        else
        {
            var handleIndex = _freeIndex;
            ref Handle handleToRecycle = ref _handles[handleIndex];

            bool isItTheOnlyFreeIndex = _freeIndex == _lastFreeIndex;
            if (isItTheOnlyFreeIndex)
            {
                _freeIndex = Tombstone;
                _lastFreeIndex = Tombstone;
            }
            else
            {
                _freeIndex = handleToRecycle.Index;
            }
            
            // Note the version has been incremented on removal too, so it's free to use already
            Handle finalHandle = new Handle(handleIndex, handleToRecycle.Version);
            uint denseIndex = (uint)_dense.Add(finalHandle{% for i in range(1, n + 1) %}, value{{i}}{% endfor %});

            handleToRecycle = handleToRecycle with { Index = denseIndex};

            return finalHandle;
        }
    }

    public bool Remove(Handle handle)
    {
        // Validate the handle points to a valid slot
        if (handle.Index >= _handles.Length)
        {
            return false;
        }

        // Check if handle is current (not stale)
        ref Handle handleToBeDeleted = ref _handles[handle.Index];
        if (handleToBeDeleted.Version != handle.Version)
        {
            return false;
        }

        // Remove from dense storage, swapping with last element if needed
        if (_dense.SwapRemoveReturnFirst((int)handleToBeDeleted.Index, out Handle handleThatGotMoved))
        {
            ref Handle swappedHandle = ref _handles[handleThatGotMoved.Index];
            swappedHandle = swappedHandle with { Index = handleToBeDeleted.Index };
        }

        // Increment version to invalidate existing handles
        handleToBeDeleted = handleToBeDeleted with 
        {
            // Increment version so all the previous instances are invalid and it's ready for future recycle
            Version = handle.Version + 1,
            Index = _freeIndex
        };

        // Update free list
        if (_freeIndex == Tombstone)
        {
            _lastFreeIndex = handle.Index;
        }

        _freeIndex = handle.Index;

        return true;
    }

    {% for i in range(1, n + 1) %}
    public bool TryGetValue{{i}}(Handle handle, out TValue{{i}} value)
    {
        if (!Contains(handle))
        {
            value = default;
            return false;
        }
        
        value = _dense.GetValue{{i+1}}((int)_handles[handle.Index].Index);
        return true;
    }
    {%- endfor %}

    public bool Contains(Handle handle)
    {
        if (handle.Index >= _handles.Length)
        {
            return false;
        }
        
        ref Handle storedHandle = ref _handles[handle.Index];
        return storedHandle.Version == handle.Version;
    }

    public Span<Handle> Handles => _dense.Values1;
    {% for i in range(1, n+1) %}
    public Span<TValue{{i}}> Values{{i}} => _dense.Values{{i+1}};
    {%- endfor %}
}
{% endfor %}
{% endfor %}