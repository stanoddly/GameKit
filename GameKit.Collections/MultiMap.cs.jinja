using System.Runtime.CompilerServices;

// Generated using jinja2-cli: jinja2 MultiMap.cs.jinja > MultiMap.cs
namespace GameKit.Collections;
{% for type in [("class", ""), ("struct", "Struct")] -%}
{% for n in range(1, 9) -%}

public {{type[0]}} MultiMap{{type[1]}}<{% for i in range(1, n + 1) %}{% if not loop.first %}, {% endif %}TValue{{i}}{% endfor %}>
{
    private FastListStruct<int> _sparse;
    private MultiArrayStruct<Handle{% for i in range(1, n + 1) %}, TValue{{i}}{% endfor %}> _dense;
    private const int TombStone = int.MaxValue;  

    public MultiMap{{type[1]}}()
    {
        _sparse = new FastListStruct<int>();
        _dense = new MultiArrayStruct<Handle{% for i in range(1, n + 1) %}, TValue{{i}}{% endfor %}>();
    }

    public void Set(Handle handle{% for i in range(1, n + 1) %}, TValue{{i}} value{{i}}{% endfor %})
    {
        if (handle.IsNull())
        {
            throw new HandleNullException();
        }

        int sparseIndex = handle;

        if (sparseIndex > _sparse.LastIndex)
        {
            _sparse.ResizeFill(sparseIndex + 1, TombStone);
        }

        ref int denseIndex = ref _sparse[sparseIndex];

        // nonexistent
        if (denseIndex == TombStone)
        {
            denseIndex = _dense.Add(handle{% for i in range(1, n + 1) %}, value{{i}}{% endfor %});
            return;
        }

        _dense.Set(denseIndex, handle{% for i in range(1, n + 1) %}, value{{i}}{% endfor %});
    }
    
    public bool Update(Handle handle{% for i in range(1, n + 1) %}, TValue{{i}} value{{i}}{% endfor %})
    {
        if (handle.IsNull())
        {
            throw new HandleNullException();
        }

        int sparseIndex = handle;

        if (sparseIndex > _sparse.LastIndex)
        {
            return false;
        }

        ref int denseIndex = ref _sparse[sparseIndex];

        // nonexistent
        if (denseIndex == TombStone)
        {
            denseIndex = _dense.Add(handle{% for i in range(1, n + 1) %}, value{{i}}{% endfor %});
            return false;
        }

        _dense.Set(denseIndex, handle{% for i in range(1, n + 1) %}, value{{i}}{% endfor %});
        return true;
    }
    
    public bool Create(Handle handle{% for i in range(1, n + 1) %}, TValue{{i}} value{{i}}{% endfor %})
    {
        if (handle.IsNull())
        {
            throw new HandleNullException();
        }

        int sparseIndex = handle;

        if (sparseIndex > _sparse.LastIndex)
        {
            _sparse.ResizeFill(sparseIndex + 1, TombStone);
        }

        ref int denseIndex = ref _sparse[sparseIndex];

        bool nonexistent = denseIndex == TombStone;
        if (nonexistent)
        {
            denseIndex = _dense.Add(handle{% for i in range(1, n + 1) %}, value{{i}}{% endfor %});
            return true;
        }

        return false;
    }

    public bool TryGet(Handle handle{% for i in range(1, n + 1) %}, out TValue{{i}} value{{i}}{% endfor %})
    {
        if (Contains(handle, out int index))
        {
            _dense.TryGetButFirst(index{% for i in range(1, n + 1) %}, out value{{i}}{% endfor %});
        
            return true;
        }

        {% for i in range(1, n + 1) %}
        value{{i}} = default;
        {%- endfor %}

        return false;
    }
    
    public bool TryGet<TResult>(Handle handle, out TResult result) where TResult: IConstructible<TResult, {% for i in range(1, n + 1) %}{% if not loop.first %}, {% endif %}TValue{{i}}{% endfor %}>
    {
        if (Contains(handle, out int index))
        {
            _dense.TryGetButFirst(index{% for i in range(1, n + 1) %}, out TValue{{i}} value{{i}}{% endfor %});
            result = TResult.Construct({% for i in range(1, n + 1) %}{% if not loop.first %}, {% endif %}value{{i}}{% endfor %});

            return true;
        }

        result = default;

        return false;
    }

    public bool Remove(Handle handle)
    {
        if (handle.IsNull())
        {
            throw new HandleNullException();
        }

        int index = handle;
        if (index > (_sparse.Length - 1))
        {
            return false;
        }

        ref int denseIndex = ref _sparse[index];

        if (denseIndex == TombStone)
        {
            return false;
        }
        
        if (_dense.SwapRemoveReturnFirst(denseIndex, out Handle swappedHandle))
        {
            ref int swappedSparseIndex = ref _sparse[(int)swappedHandle];
            swappedSparseIndex = denseIndex;
        }

        denseIndex = TombStone;
        return true;
    }

    public bool Contains(Handle handle)
    {
        return Contains(handle, out _);
    }
    
    public bool Contains(Handle handle, out int handleIndex) 
    {
        int index = handle;
        if (index > _sparse.LastIndex)
        {
            handleIndex = default;
            return false;
        }
        
        handleIndex = _sparse[index];

        return handleIndex != TombStone;
    }
    
    {% for i in range(1, n + 1) %}
    public bool TryGetValue{{i}}(Handle handle, out TValue{{i}} value)
    {
        if (!Contains(handle, out int index))
        {
            value = default;
            return false;
        }
        
        return _dense.TryGetValue{{i+1}}(index, out value);
    }
    {%- endfor %}

    {% for i in range(1, n + 1) %}
    public ref TValue{{i}} UnsafeGetRefValue{{i}}(Handle handle, out bool exists)
    {
        if (!Contains(handle, out int index))
        {
            exists = false;
            return ref Unsafe.NullRef<TValue{{i}}>();
        }

        exists = true;
        return ref _dense.GetRefValue{{i+1}}(index);
    }
    {%- endfor %}
    
    {% for i in range(1, n + 1) %}
    public void GetValues{{i}}OrDefault(ReadOnlySpan<Handle> handles, Span<TValue{{i}}> values)
    {
        if (handles.Length > values.Length)
        {
            throw new ArgumentException("Length of values span must be greater than or equal to length of handles span.", nameof(values));
        }
        
        for (int i = 0; i < handles.Length; i++)
        {
            if (Contains(handles[i], out int index))
            {
                values[index] = _dense.GetValue{{i + 1}}(index);
            }
            else
            {
                values[index] = default;
            }
        }
    }
    {%- endfor %}

    public int Length => _dense.Length;

    public ReadOnlySpan<Handle> Handles => _dense.Values1;
    {% for i in range(1, n+1) %}
    public Span<TValue{{i}}> Values{{i}} => _dense.Values{{i+1}};
    {%- endfor %}
}

{% endfor %}
{% endfor %}
